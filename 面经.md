### PHP
1. 面向对象三大特性：封装、继承、多态
2. PHP是怎样实现多态的：PHP用接口实现多态，一个类拥有其父类和已实现接口的身份。多继承可以使用接口与组合模拟。
3. php魔术常量
    * __LINE__:文件中的当前行号
    * __FILE__：文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名
    * __DIR__：文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录
    * __METHOD__：类的方法名。返回该方法被定义时的名字
4. PHP超级全局变量
    * $_SERVER:包含了诸如头信息、路径、以及脚本位置等等信息的数组
        * 当前用户的IP地址/主机名/端口号：$_SERVER['REMOTE_ADDR/HOST/PORT']
        * 当前执行脚本的绝对路径：$_SERVER['SCRIPT_FILENAME']
    * $_POST/$_REQUEST/$_GET:收集表单数据
5. array_merge 和 '+'的区别：array_merge如果有重复的键会被覆盖，有重复的值不会被覆盖；+ 直接合并两个数组，不会产生覆盖
6. 魔术方法
    * __call():当调用不存在的方法时会自动调用的方法
    * __autoload()：在实例化一个尚未被定义的类是会自动调用此方法来加载类文件
    * __set()：当给未定义的变量赋值时会调用这个方法
    * __get()：当获取未定义的变量的值时会调用这个方法
    * __clone()：克隆一个对象
    * __tostring()：当输出一个对象时自动调用此方法
7. PHP垃圾回收：每个php变量存在一个叫“zval”的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。一个是“is_ref”，是个布尔值，用来标识这个变量是否属于引用集合。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于PHP允许用户通过使用&来使用自定义引用，zval变量容器中还有一个引用计数机制，来优化内存引用。第二个额外字节是“refcount”，用以表示指向这个zval变量容器的变量个数。所有的符号存在一个符号表中，其中每个符号都有作用域，那些主脚本和每个函数或者方法也都有作用域
8. require和include的区别：include在用到时加载，require在一开始加载；include引入文件时，如果碰到错误，会给出提示，并继续运行下边的代码，而require会停止运行下边的代码；
9. cookie和session的区别：
    * 作用范围不同，cookie只保存在客户端，session保存在服务器端
    * 存取方式的不同：cookie只能保存ASCII，session可以存取任何数据类型，一般情况下我们可以在session中保持一些常用变量信息
    * 有效期不同：cookie可设置为长时间保持（默认登陆），session一般失效时间较短，客户端关闭或者session超时都会失效
    * 隐私策略不同：cookie相对来说容易遭到不法获取不安全
    * 存储大小不同：单个cookie保存的数据不能超过4k，session可存储数据远高于cookie
10. isset和empty的区别：
    * isset：若变量不存在或者变量存在，但其值为NULL，返回false
    * empty：若变量存在且其值为空字符串，0，NULL，FALSE，空数组以及没有任何属性的对象时，返回TURE

### MySQL
1. 三大范式:
    * 第一范式：所有的列都应该是原子性的。数据库的每一列都是不可分割的原子数据项
    * 第二范式：在第一范式的基础上，非key属性必须完全依赖于主键
    * 第三范式：在第二范式的基础上，确保表中各列与主键直接相关，即各列与主键列都是一种直接依赖关系，无传递依赖
2. 存储引擎：InnoDb与MyISAM的区别
    * InnoDB：是5.7的默认的存储引擎，支持事务，支持行锁，支持外键。所有的表都保存在同一个数据文件中，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB
    * MyISAM：不支持事务，表级锁，不支持外键，强调的是性能。每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD，索引文件的扩展名.MYI。
#### 事务
3. 隔离级别
    * READ UNCOMMITED（未提交读）：事务中的修改，即使没有提交，对其他事务也是可见的
    * READ COMMITED（读已提交）：一个事务直到提交之前，所做的任何修改对其他事务都是不可见的
    * REPEATEABLE READ（可重复读）：保证了在同一个事务中多次读取同样记录的结果是一致的。是MySQL的默认隔离级别。解决脏读
    * SERIALIZABLE（可串行化）：最高的隔离级别。通过强制事务串行执行，避免了幻读。在读取的每一行数据都加了锁，可能会导致大量的超时和锁争用的问题
4. 事务产生的问题
    * 幻读：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务在读取这个范围内的记录时，会产生幻行。
    * 脏读：一个事务读取到了另外一个未提交事务的修改
5. 死锁：两个或多个事务在同一资源上相互调用，并请求锁定对方的资源，从而到自己恶心循环的现象
6. 死锁解决办法：部分或者完全回滚其中一个事务。
#### 索引
7. B+树：一棵m阶的B+树，有k个子树的中间节点包含有k个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。所有的叶子节点中包含了全部元素的信息，以及指向含这些元素记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接。所有的中间节点元素都同时存在于子节点，在子节点元素中是最大或最小元素
8. 卫星数据：索引元素所指向的数据记录，比如数据库中的某一行。只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联
9. B树和B+树的区别
    * B+树的节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素
    * 在数据量相同的情况下，B+树的结构比B树更加矮胖，查询的IO次数页更少，磁盘读写代价更低
    * B+树的查询必须找到叶子节点，而B树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。所以B树的查找性能并不稳定，而B+树的每一次查找都是稳定的
    * B树做范围查询时，只能依靠繁琐的中序遍历，而B+树只需在链表上做遍历即可
10. 最左匹配原则（联合索引）
    * 不可以在范围查询时使用，例如'>'、'<'
    * = 和 in可以乱序
    * 尽量选择区分度高的列作为索引，即字段不重复的比例
    * 索引列不能参与计算
    * 模糊匹配语句无法使用索引
    * or前后没有同时使用索引，无法使用
    * 数据类型出现隐式转换无法使用索引
#### 优化
1. SQL语句的优化
    * 将一个大的查询分为多个小的相同的查询
    * 分解关联查询
    * 减少冗余字段的查询
    * 分页查询可以记录上次查询的最大ID，下次查询时直接根据ID来查询