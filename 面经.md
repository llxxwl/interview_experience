### PHP
1. 面向对象三大特性：封装、继承、多态
2. PHP是怎样实现多态的：PHP用接口实现多态，一个类拥有其父类和已实现接口的身份。多继承可以使用接口与组合模拟。
3. php魔术常量
    * __LINE__:文件中的当前行号
    * __FILE__：文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名
    * __DIR__：文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录
    * __METHOD__：类的方法名。返回该方法被定义时的名字
4. PHP超级全局变量
    * $_SERVER:包含了诸如头信息、路径、以及脚本位置等等信息的数组
        * 当前用户的IP地址/主机名/端口号：$_SERVER['REMOTE_ADDR/HOST/PORT']
        * 当前执行脚本的绝对路径：$_SERVER['SCRIPT_FILENAME']
    * $_POST/$_REQUEST/$_GET:收集表单数据
5. array_merge 和 '+'的区别：array_merge如果有重复的键会被覆盖，有重复的值不会被覆盖；+ 直接合并两个数组，不会产生覆盖
6. 魔术方法
    * __call():当调用不存在的方法时会自动调用的方法
    * __autoload()：在实例化一个尚未被定义的类是会自动调用此方法来加载类文件
    * __set()：当给未定义的变量赋值时会调用这个方法
    * __get()：当获取未定义的变量的值时会调用这个方法
    * __clone()：克隆一个对象
    * __tostring()：当输出一个对象时自动调用此方法
7. PHP垃圾回收：每个php变量存在一个叫“zval”的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。一个是“is_ref”，是个布尔值，用来标识这个变量是否属于引用集合。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于PHP允许用户通过使用&来使用自定义引用，zval变量容器中还有一个引用计数机制，来优化内存引用。第二个额外字节是“refcount”，用以表示指向这个zval变量容器的变量个数。所有的符号存在一个符号表中，其中每个符号都有作用域，那些主脚本和每个函数或者方法也都有作用域
8. require和include的区别：include在用到时加载，require在一开始加载；include引入文件时，如果碰到错误，会给出提示，并继续运行下边的代码，而require会停止运行下边的代码；
9. cookie和session的区别：
    * 作用范围不同，cookie只保存在客户端，session保存在服务器端
    * 存取方式的不同：cookie只能保存ASCII，session可以存取任何数据类型，一般情况下我们可以在session中保持一些常用变量信息
    * 有效期不同：cookie可设置为长时间保持（默认登陆），session一般失效时间较短，客户端关闭或者session超时都会失效
    * 隐私策略不同：cookie相对来说容易遭到不法获取不安全
    * 存储大小不同：单个cookie保存的数据不能超过4k，session可存储数据远高于cookie
10. isset和empty的区别：
    * isset：若变量不存在或者变量存在，但其值为NULL，返回false
    * empty：若变量存在且其值为空字符串，0，NULL，FALSE，空数组以及没有任何属性的对象时，返回TURE
11. echo,print,print_r的区别：
    * echo和print都是语言结构，print_r是函数
    * echo 输出多个值，print只能输出一个值
    * echo和print只能输出字符串，print_r可以输出数组
12. private，public，protected
    * private：私有属性，仅能在类的内部访问
    * protected：保护成员，在类内部和继承类中访问
    * public：公共成员，没有访问限制
13. cgi,fast-cgi,php-fpm:
    * cgi:cgi是一个规范，是web服务器调用外部程序时所使用的一种服务端应用的规范。cgi针对每个HTTP请求都会fork一个新进程来进行处理，然后把这个进程处理完的结果通过web服务器转给用户，fork的新进程随之退出。如果用户下次请求动态资源，再fork新进程
    * fast-cgi：会fork一个master进程，解析配置文件，初始化执行环境，然后再fork多个worker进程，当HTTP请求过来时，master进程会将其传给一个worker进程，然后立即接收下一个请求，避免了重复的初始化操作。当进程不够用时，可以预先启动几个worker进程等待；当空闲进程太多时，会自己关闭一部分。
    * php-fpm：是PHP版本的fast CGI协议实现。负责管理一个进程池来处理来自web服务器的HTTP动态请求，在php-fpm中，master进程负责与web服务器进行通信，接受HTTP请求，再将请求转发给worker进程处理，worker进程主要负责动态执行PHP代码，处理完成后，将处理结果返回给web服务器，再由web服务器将结果发送给客户端
14. PHP执行过程
    * 语法解析，词法解析
    * 转变成表达式
    * 生成字节码，opchache缓存
    * 执行脚本
15. filter_var():检查函数

### MySQL
1. 三大范式:
    * 第一范式：所有的列都应该是原子性的。数据库的每一列都是不可分割的原子数据项
    * 第二范式：在第一范式的基础上，非key属性必须完全依赖于主键
    * 第三范式：在第二范式的基础上，确保表中各列与主键直接相关，即各列与主键列都是一种直接依赖关系，无传递依赖
2. 存储引擎：InnoDb与MyISAM的区别
    * InnoDB：是5.7的默认的存储引擎，支持事务，支持行锁，支持外键。所有的表都保存在同一个数据文件中，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB
    * MyISAM：不支持事务，表级锁，不支持外键，强调的是性能。每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD，索引文件的扩展名.MYI。
#### 事务
2. 特征：（ACID）
    * 原子性（atomicity）：一个事务必须被看作是一个不可分割的最小单元
    * 一致性（consistency）：数据库总是从一个一致性的状态转移到另外一个一致性的状态
    * 隔离性（isolation）：一个事务所做的修改在提交前，另外的事务不可见
    * 持久性（durability）：一旦事务提交，所做的修改永久性的保存到数据库里
3. 隔离级别
    * READ UNCOMMITED（未提交读）：事务中的修改，即使没有提交，对其他事务也是可见的
    * READ COMMITED（读已提交）：一个事务直到提交之前，所做的任何修改对其他事务都是不可见的
    * REPEATEABLE READ（可重复读）：保证了在同一个事务中多次读取同样记录的结果是一致的。是MySQL的默认隔离级别。解决脏读
    * SERIALIZABLE（可串行化）：最高的隔离级别。通过强制事务串行执行，避免了幻读。在读取的每一行数据都加了锁，可能会导致大量的超时和锁争用的问题
4. 事务产生的问题
    * 幻读：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务在读取这个范围内的记录时，会产生幻行。
    * 脏读：一个事务读取到了另外一个未提交事务的修改
    * 不可重复读：在一个事务中的两次查询数据不一致，可能是两次查询过程中间插入了一个事务更新的原有的数据
5. 死锁：两个或多个事务在同一资源上相互调用，并请求锁定对方的资源，从而到自己恶性循环的现象
6. 死锁解决办法：部分或者完全回滚其中一个事务。
7. 死锁的避免：
    * 在程序中，操作多张表时，尽量以相同的顺序来访问
    * 批量操作单张表数据的时候，先对数据进行排序
    * 申请足够级别的锁，如果要操作数据，就申请排他锁
    * 尽量使用索引访问数据，避免没有where条件的操作，防止锁表
    * 大事务化成小事务
    * 使用等值查询而不是范围查询，命中纪录，避免间隙锁对并发的影响（间隙锁：记录不存在时，使用的都是间隙锁）
#### 索引
7. B+树：一棵m阶的B+树，有k个子树的中间节点包含有k个元素，每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。所有的叶子节点中包含了全部元素的信息，以及指向含这些元素记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接。所有的中间节点元素都同时存在于子节点，在子节点元素中是最大或最小元素
8. 卫星数据：索引元素所指向的数据记录，比如数据库中的某一行。只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联
9. B树和B+树的区别
    * B+树的节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素
    * 在数据量相同的情况下，B+树的结构比B树更加矮胖，查询的IO次数页更少，磁盘读写代价更低
    * B+树的查询必须找到叶子节点，而B树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。所以B树的查找性能并不稳定，而B+树的每一次查找都是稳定的
    * B树做范围查询时，只能依靠繁琐的中序遍历，而B+树只需在链表上做遍历即可
10. 最左匹配原则（联合索引）
    * 不可以在范围查询时使用，例如'>'、'<'
    * = 和 in可以乱序
    * 尽量选择区分度高的列作为索引，即字段不重复的比例
    * 索引列不能参与计算
    * 模糊匹配语句无法使用索引
    * or前后没有同时使用索引，无法使用
    * 数据类型出现隐式转换无法使用索引
11. 页：一页16kb，只需要一次磁盘I/O（空间换时间），一页就是一个节点 
    * 结构：
        * 页头（两个指针prev，next）
        * 目录（指向数据的第一条记录，存主键值）
        * 数据（插入的时候按主键排序，主键不自增）
#### 优化
1. SQL语句的优化
    * 将一个大的查询分为多个小的相同的查询
    * 分解关联查询
    * 减少冗余字段的查询
    * 分页查询可以记录上次查询的最大ID，下次查询时直接根据ID来查询
2. 大表数据查询的优化
    * 加缓存
    * 主从复制，读写分离
    * 垂直拆分：根据模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统
    * 水平切分：针对数据量大的表，选一个合理的key，为了有好的查询效率，表结构也要改动，做一定的冗余，将数据定位到限定的表上去查，而不是扫描全部的表
3. 主从复制，读写分离
    * 原理：主服务器上的任何修改都会保存在binary log里，从服务器上启动一个i/o线程，连接到主服务器上面请求读取二进制日志写到本地的一个Realy log（中继日志）里面。从服务器上面开启一个SQL线程定时检查Realy Log，如果发现有更改，立即同步更改
#### 日志
1.  Error log：记录MySQL运行过程中的error、warning、note等信息，系统出错或者某条记录出问题可以查看error日志
2.  General Query log：记录MySQL的日常日志，包括查询、修改、更新的每条SQL
    * 查看MySQL是否启用了查询日志：`show global variables like %general%`
3. Binary Log：包含一些事件，这些事件描述了数据库的改动，如建表、数据改动等，主要用于备份恢复、回滚操作等
    * 包含了所有更新了数据或者已经潜在更新了的数据（比如没有匹配任何行的一个delete）
    * 包含关于每个更新数据库的语句的执行时间信息
    * 不包含没有修改任何数据的语句，如果需要启用该选项，需要开启通用日志功能
    * 主要目的是尽可能的将数据库恢复到数据库故障点，因为二进制日志包含备份后进行的所有更新
    * 用于在主复制服务器上记录所有将发送给从服务器的语句
    * 启用该选项数据库性能降低1%，但保证数据库完整性，对于重要数据库值得以性能换完整
4. Slow Query Log：记录慢查询的日志，用来记录执行时间超过指定时间的查询语句
5. 事务日志：InnoDB特有的日志，可以帮助提高事务的效率
6. 中继日志：用于主从复制架构中的从服务器中，从服务器的slave进程从主服务器处获取二进制日志的内容并写入中继日志，然后由IO进程读取并执行中继日志的语句
#### 生命周期
1. 应用服务器与数据库服务器建立一个连接
2. 数据库进程拿到请求sql
3. 解析并生成执行计划，执行
4. 读取数据到内存并进行逻辑处理
5. 通过步骤一的连接，发送结果到客户端
6. 关掉链接，释放资源
#### 锁
1. 共享锁：属于行锁，又称为读锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能写
2. 排他锁：又称写锁，排他锁不能与其他锁共存。如一个事务获取了一个数据行的排他锁，其他事务就不能在获取该行的其他锁。只有该获取了排他锁的事务是可以对数据进行读取和修改（删除、更新、插入自动加锁）
3. 意向锁：由数据引擎自己维护，加锁前必须先取得该表对应的意向锁
4. 锁住的是什么：索引
#### 其他
1. sql_mode：默认是空值，在这种设置下会允许一些非法操作，比如允许一些非法数据的插入
    * MySQL5.7之后，sql_mode中ONLY_FULL_GROUP_BY模式默认设置为打开状态。语义是明确select list中所有列的值都是明确语义。使用any_value函数来抑制此报错

### 网络

#### 三次握手
1. 第一次握手：客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等到服务器确认
2. 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态
3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送一个确认包，建立连接
4. 为什么不能用两次握手进行连接：3次握手完成两个重要的功能，既要双方做好发送数据的准备，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认，两次握手可能会有之前未生效的连接请求报文段被发送给服务器，避免错误
#### 四次挥手
1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u，此时，客户端进入FIN-WAIT-1（终止等待1）状态。TCP规定，FIN报文段即使不携带数据，也要消耗一个序号
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v。此时，服务端进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要欣然接受，这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间
3. 客户端收到服务器的确认请求后，此时，客户端进入终止等待2状态，等待服务器发送连接释放报文
4. 服务器将最后的数据发送完毕后，就像客户端发送连接释放报文，，FIN=1，ack=w+1，而自己的序列号是seq=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进行了LAST-ACK（最后确认）状态，等待客户端的确认
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1.此时，客户端就进入了TIME-WAIT状态，此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态
7. time-wait状态是一种TCP状态。等待2MSL可以保证客户端最后一个报文段能够到达服务器，如果未到达，服务器会超时重传连接释放报文段，使得客户端、服务器都可以正常进入到关闭状态
#### HTTP状态码
1. 2**：成功，操作被成功接收并处理
    * 200：请求成功。一般用于GET与POST请求
    * 201：已创建，成功请求并创建了新的资源
    * 202：已接受，已经接受请求，但未处理完成
    * 204：无内容，服务器成功处理，但未返回内容
    * 206：部分内容，服务器成功处理了部分GET请求
2. 3**：重定向
    * 300：多种选择，请求的资源可包括多个位置
    * 301：永久重定向，请求的资源已经被移动到新的uri，返回信息会包括新的uri，浏览器会自动定向到uri
    * 302：临时重定向
    * 303：查看其它地址
    * 304：所请求的资源未修改
    * 305：使用代理
3. 4**：客户端错误，请求包含语法错误或无法完成请求
    400：客户端语法错误，服务器无法理解
    401：未进行身份认证
    403：服务器理解客户端请求，但拒绝执行
    404：服务器无法根据 客户端的请求找到资源
    405：客户端请求中的方法被禁止
    408：请求时间过长，超时
    415：服务器无法处理请求附带的媒体格式
4. 5**：服务器错误，服务器在处理请求的过程中发生了错误
    500：服务器内部错误，无法完成请求
    501：服务器 不支持请求的原因，无法完成请求
    502：作为网关或者代理工作的服务器尝试执行请求时，从远程服务器收到了一个无效的响应
    503：由于超载或系统维护，服务器暂时 无法处理客户端的请求
    505：服务器不支持请求的HTTP协议的版本，无法完成处理
#### 一次url请求的过程
1. dns解析
2. 与服务器进行三次握手，建立TCP连接
3. 发送HTTP请求
4. 服务器响应数据发送给客户端浏览器
5. 四次挥手，tcp连接释放
6. 浏览器解析渲染页面


#### 常用协议端口
* ftp 20/21
* ssh 22
* telnet 23
* http 80
* https 443
* dns 53
* dhcp 67/68

#### OSI七层模型
1. 应用层
    * 功能：文件传输、电子邮件、文件服务、虚拟终端；为操作系统或者网络应用程序提供访问网络服务的接口
    * TCP/IP协议：TFTP、HTTP、SNMP、FTP、SMTP、DNS、TELNET
2. 表示层
    * 功能：数据格式化，代码转换，数据加密，数据压缩解压缩
3. 会话层
    * 功能：解除或建立与别的接点的联系,服务器验证用户登录
4. 传输层
    * 功能：提供端对端的接口
    * 协议：TCP，UDP
5. 网络层
    * 功能：为数据包选择路由
    * 协议：IP、ICMP、RIP、OSPF、BGP、IGMP
6. 数据链路层
    * 功能：传输有地址的帧以及错误检测功能，在不可靠的物理介质上提供可靠的传输。物理地址寻址，数据的成帧，流量控制
    * 协议：SLIP，CSLIP，PPP，ARP，RARP，MTU
7. 物理层
    * 功能：以二进制数据形式在物理媒体上传输数据
    * 协议：ISO，IEEE
#### TCP与UDP的区别
1. TCP：可靠、稳定，但是慢，效率低，占用系统资源高
2. UDP：无状态传输，即无连接。容易丢包
### Linux
#### 常用命令
1. uname：显示系统信息
2. ps -aux：显示进程状态
3. grep：在文本文件中查找某个字符串
4. df -h：查看磁盘大小，带有单位显示磁盘信息
5. du -h：查看目录大小
6. tar -zcvf：打包并gzip压缩
    * -c：归档文件
    * -x：压缩文件
    * -z：gzip压缩文件
    * -j：bzip压缩文件
    * -v：显示压缩或解压缩过程
    * -f：使用档名
7. awk
    * 内建变量
        * $0:当前记录（存放着整个行的内容）
        * $1~$n：当前记录的第n个字段，字段间由FS分隔
        * FS：输入字段分隔符，默认是空格或Tab
        * NF：当前记录的字段个数，就是有多少列
        * NR：已经读出的记录数，就是行号
        * FNR：各个文件自己的行数
        * RS：输入的记录分隔符，默认是换行符
        * OFS：输出字段分隔符，默认是空格
        * ORS：输出的记录分隔符，默认是换行符
        * FILENAME：当前输入文件的名字
    * 示例：
        * 打印文件文件名、行数、列数：`awk -F:'{print FILENAME " " NR " " NF " " $0} /etc/passwd'`
        * 打印第一列和第三列的值：`awk -F:'{print $1 " " $3}' /etc/passwd`
        * 打印20-30行的内容：`awk '{if(NR>20 && NR<30) print $1}' /etc/passwd`
        * 搜索文件下有root关键字的所有行：`awk '/root/' /etc/passwd`
        * 列出目录下所有文件夹：ls -lF | awk '/^d/'
        * 查看最近登陆最多的IP信息：`last | awk '{S[$3]++}END{for(a in S){print S[a],a}}' | uniq|sort -rh`
8. lsof filename：查看文件被进程占用情况
#### nginx
1. php-fpm 与 nginx通信机制
    * fastcgi：是web server与web Application之间数据交换的一种协议
    * php-fpm：是PHP对web server 提供的fastcgi协议的接口程序，额外还提供了相对智能一些的任务管理
    * fastcgi是一个协议，php-fpm实现了这个协议
2. php-fpm的运行逻辑：fpm的实现就是创建一个master进程，在master进程中创建worker pool并监听socket，然后fork出多个子进程，这些worker在启动后阻塞在fcgi_accept_request()上，各自accept请求，有请求到达后worker开始读取请求数据，读取完成后开始处理然后在返回，在这期间是不会接收其他请求的，也就是说fpm的子进程同时只能响应一个请求，只有把这个请求处理完成后才会accept下一个请求，所以有多少子进程就能同时处理多少请求

#### 缓存
1. cdn：空间换时间，自动选择最近的节点内容，适合存储更新很少的静态内容，文件更新慢
2. bigPipe：（片段缓存）
    * 将页面划分成一个个小块
    * 利用ob_flush与flush将缓冲区的内容提前输出给浏览器
    * 浏览器在一个请求中不断的接收并渲染到页面，逐个小块显示
3. memcache和memcached有什么区别
    * memcache基于pecl版本，memcached基于libmemcached开发
    * memcache面向对象、面向过程，memcached只面向对象，但提供了更多的协议和接口
4. 浏览器缓存：
    * 页面链接的请求无需做长时间缓存
    * 敏感数据不宜做缓存
    * 静态资源部分，通常会设定一个较长的缓存时间
    * 冷热数据分离，减少请求量
    * 不要随意修改文件
    * 不建议使用Etag，尤其是分布式

#### Redis
1. 常用命令
    * set key value：设置一个键值对
    * get key：获取键值
    * del key：当key存在时删除key
    * exists key：判断key是否存在
    * expire key second：key设置过期时间
    * move key db：将当前数据库的key移动到给定的数据库中
    * persist key：移除key的过期时间，key将永久保持
    * type key：返回key所存储的值的类型
    * getrange key start end：返回key中字符串值的子串
    * strlen key：返回字符串的长度
    * incr/decr key：将key的值自增/自减1
    * append key value：如果key已经存在且key是一个字符串，增加指定的value到原value的末尾
    * hlen key：获取哈希表中字段的数量
    * hkeys key：获取哈希表中所有字段
    * hvals key：获取哈希表中所有值
    * llen key：获取列表长度
    * lrange key start stop：获取指定范围内的元素
    * scard key：获取集合的成员数
    * sadd key member1：向集合添加一个或多个成员
    * smembers key：返回集合中的所有成员
    * zcard key：获取有序集合的成员数
    * zcount key min max：计算有序集合中指定分数区间的成员数
    * zincrby key increment member：有序集合中对指定成员的分数加上增量increment
    * zscore key member：返回成员的分数值
2. 数据类型
    * 字符串：热点数据缓存、文章的阅读量、微博点赞数
    * hash：购物车
    * 列表：消息队列、用户消息时间线
    * 有序集合：排行榜
    * 集合：抽奖、点赞、签到、打卡、关注列表
3. 底层实现
    * 简单动态字符串
    ```c
        struct sdshdr {
            // 字符串长度
            int len;
            // 未使用的字节数
            int free;
            // 字节数组，用于保存字符串
            char buf[];
        }
    ```
        - 常数复杂度获取字符串长度
        - 杜绝缓冲区溢出：在字符修改时，会首先根据len检查内存空间是否满足，如果不满足需求，会进行相应的空间扩展，然后再进行修改操作，不会造成缓冲区溢出
        - 减少修改字符串的内存重新分配次数：
            * 空间预分配：对字符串进行空间扩展时，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数
            * 惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回缩短后多余的字节，而是使用free属性将这些字节数记录下来，等待后续使用
        - 二进制安全：以处理二进制的方式来处理buf中的元素，并且sds不是以空字符串来判断结束，而是以len属性表示的长度来判断字符串是否结束
    * 跳跃表（只能用于元素有序的情况）
    ```c
        // 跳跃表节点
        typedef struct zskiplistNode {
            struct zskiplistNode *backward;     // 后退指针
            double score;                       // 分值
            robj *obj;                          // 成员对象
            struct zskiplistLevel {             // 层
                struct zskiplistNode *forward;  // 前进指针
                unsigned int span;              // 跨度
            } level[];
        } zskiplistNode;
    ```
        - 层可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快
        - 跨度是用来计算排位的，在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位
    ```c
        typedef struct zskiplist {
            struct zskiplistNode *header, *tail;    // 表头结点和表尾节点
            unsigned long length;                   // 表中节点的数量
            int level;                              // 表中层数最大的节点的层数
        } zskiplist;
    ```
        - 与平衡树的对比
            * 跳表范围查询效率更高
            * 跳表内存占用更小，跳表每个节点的指针数量为1/（1-p），平衡树的每个节点指针数都为2
            * 跳表插入和删除操作只需要修改相邻节点的指针，平衡树变更会引起子树的调整
4. 持久化
    * RDB持久化：按照指定时间间隔对数据集生成的时间点快照。
        - 以紧缩的二进制文件保存Redis数据库某一时刻所有数据对象的内存快照，可用于数据备份、转移与恢复。
        - 无法保证实时性
        - 适合全量复制、备份等场景，对灾难恢复、数据迁移非常友好；数据恢复速度快。
    * AOF持久化：完全持久化策略，
        - 这里的file存储的是引起Redis数据修改的命令集合，这些集合按照Redis Server的处理顺序追加到文件中。当重启Redis时，Redis就可以从头读取AOF的指令并重放，从而恢复关闭前的数据状态
        - 默认是关闭的
        - 持久化流程：命令追加、文件写入与同步、文件重写、重启加载
        - 实时性好，文件只有append操作，文件可在后台自动重写
5. 常见问题及解决方案
    * 缓存雪崩：同一时间大量缓存失效，导致请求直接查询数据库，数据库内存和CPU压力增加甚至宕机
        1. 热点数据永不过期或者分布到不同实例，降低单机故障问题
        2. 缓存时间添加随机数，防止大量缓存同时失效
    * 缓存穿透：缓存和数据库都没有数据，大量请求下，所有请求直接击穿到数据库，导致宕机
        1. 布隆过滤器
        2. 空缓存
        3. 业务层参数过滤
    * 缓存击穿：数据库中有数据，但是缓存突然失效之后发生大量请求导致数据库压力增加甚至打垮宕机
        1. 热点数据永不过期
        2. 添加互斥锁，只让一个请求通过，只有一个请求去数据库拉取数据